# Babiling
#
# Copyright (C) 2015 Neil Roberts
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from PIL import Image
import sys
import os

class Node:
    def __init__(self, x, y, w, h):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.children = None
        self.image = None

    def __iter__(self):
        image_nodes = list()
        self._get_nodes(image_nodes)
        return iter(image_nodes)

    def _get_nodes(self, image_nodes):
        if self.image:
            image_nodes.append(self)
        if self.children:
            for child in self.children:
                child._get_nodes(image_nodes)

    def _split_horizontally(self, width):
        if self.w == width:
            return self

        self.children = (Node(self.x,
                              self.y,
                              width,
                              self.h),
                         Node(self.x + width,
                              self.y,
                              self.w - width,
                              self.h))

        return self.children[0]

    def _split_vertically(self, height):
        if self.h == height:
            return self

        self.children = (Node(self.x,
                              self.y,
                              self.w,
                              height),
                         Node(self.x,
                              self.y + height,
                              self.w,
                              self.h - height))

        return self.children[0]

    def add(self, image):
        w, h = image.size

        if w > self.w or h > self.h:
            return False

        if self.children:
            if self.children[0].add(image):
                return True
            else:
                return self.children[1].add(image)

        if self.image:
            return False

        # Split according to whichever axis will leave us with the
        # largest space
        if self.w - w > self.h - h:
            found_node = self._split_horizontally(w)
            found_node = found_node._split_vertically(h)
        else:
            found_node = self._split_vertically(h)
            found_node = found_node._split_horizontally(w)

        found_node.image = image

        return True

    def get_minimum_size(self):
        if self.image:
            return (self.x + self.w, self.y + self.h)
        if self.children:
            return tuple(map(max, *map(Node.get_minimum_size, self.children)))
        return (0, 0)

def try_make_atlas(w, h, images):
    root = Node(0, 0, w, h)

    for image in images:
        if not root.add(image):
            return None

    return root

def make_atlas(images):
    w = 1
    h = 1

    while True:
        atlas = try_make_atlas(w, h, images)
        if atlas != None:
            return atlas
        if w < h:
            w *= 2
        else:
            h *= 2

def sort_by_size(image):
    size = image.size
    return -size[0] * size[1]

def open_image(filename):
    image = Image.open(filename)
    image.name = os.path.splitext(os.path.basename(filename))[0]
    return image

atlas = make_atlas(sorted(map(open_image, sys.argv[3:]), key = sort_by_size))

atlas_image = Image.new('RGBA', atlas.get_minimum_size())

header = open(sys.argv[2], "w")

header.write('/* Automatically generated by make-atlas.py. Do not edit */\n')

for node in atlas:
    atlas_image.paste(node.image, (node.x, node.y))

    print('static const struct fv_hud_image\n',
          'fv_hud_image_', node.image.name, ' = { ',
          node.x, ', ', node.y, ', ',
          node.w, ', ', node.h, ' };\n',
          sep='',
          file=header)

atlas_image.save(sys.argv[1])
